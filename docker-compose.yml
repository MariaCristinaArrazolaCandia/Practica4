
services:
  backend:
    build: ./api
    env_file:
      - ./api/.env
    command: uvicorn main:app --host 0.0.0.0 --port 8070 --reload
    volumes:
      - ./api:/app
      - ./data:/data
      - ./data/charts:/data/charts
    ports:
      - "8070:8070"
    depends_on:
      - mysql
      - mongo
      - rabbitmq

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    # command: npm start
    container_name: frontend-react
    ports:
      - "3000:3000"
    depends_on:
      - backend
    environment:
      - CHOKIDAR_USEPOLLING=true
    # ==========================================================
    # VOLÃšMENES PARA SINCRONIZACIÃ“N DE CÃ“DIGO DEL FRONT
    # ==========================================================
    volumes:
      # CÃ³digo fuente del frontend
      - ./frontend:/frontend
      # NO montar node_modules desde el host
      - /frontend/node_modules

  worker:
    build: ./worker
    # ðŸ‘‡ IMPORTANTE: apunta al objeto celery_app definido en tasks.py
    command: celery -A tasks.celery_app worker --loglevel=info
    volumes:
      - ./worker:/worker
      - ./data:/data
      - ./data/charts:/data/charts
    depends_on:
      - rabbitmq
      - mysql
      - mongo
      # backend no es estrictamente necesario para que el worker arranque

  mysql:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: root123
      MYSQL_DATABASE: sensor_monitoring
    volumes:
      - ./base.sql:/docker-entrypoint-initdb.d/base.sql
      - mysql_data:/var/lib/mysql
    ports:
      - "3307:3306"  # mapeo a 3307 para evitar conflictos con MySQL local

  mongo:
    image: mongo:6
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"     # broker AMQP que Celery va a usar
      - "15672:15672"   # panel web de RabbitMQ

volumes:
  mysql_data:
  mongo_data: